<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">es2015/di/injector.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/brn/react-mvi" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getProcess">getProcess</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-run">run</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-runner">runner</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isDefined">isDefined</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">component</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es2015/component/context.js~Context.html">Context</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es2015/component/subscriber.js~Subscriber.html">Subscriber</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-context">context</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-setContext">setContext</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-component">component</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ContextReactTypes">ContextReactTypes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-SUBSCRIBER_MARK">SUBSCRIBER_MARK</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Tags">Tags</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">di</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es2015/di/abstract-module.js~AbstractModule.html">AbstractModule</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es2015/di/binding.js~BindingPlaceholder.html">BindingPlaceholder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es2015/di/binding.js~ClassTypeOption.html">ClassTypeOption</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es2015/di/binding.js~InterceptPlaceholder.html">InterceptPlaceholder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es2015/di/binding.js~TemplatePlaceholder.html">TemplatePlaceholder</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es2015/di/injector.js~Injector.html">Injector</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es2015/di/method-proxy.js~MethodInvocation.html">MethodInvocation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createModule">createModule</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-inject">inject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-param">param</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-intercept">intercept</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-interceptAll">interceptAll</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dynamicTargetSymbol">dynamicTargetSymbol</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-injectionTargetSymbol">injectionTargetSymbol</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-INJECTION_NAME_SYMBOL">INJECTION_NAME_SYMBOL</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">io</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es2015/io/io.js~IOModule.html">IOModule</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es2015/io/io.js~IOResponse.html">IOResponse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/es2015/io/io.js~SubjectStore.html">SubjectStore</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-io">io</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-IO_MARK">IO_MARK</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-appendIOModuleKey">appendIOModuleKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getIOModules">getIOModules</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">shims</div><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Symbol">Symbol</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">es2015/di/injector.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// -*- mode: typescript -*-
/**
 * The MIT License (MIT)
 * Copyright (c) Taketoshi Aono
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;),
 * to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * @fileoverview
 * @author Taketoshi Aono
 */
import { MethodInvocation } from &apos;./method-proxy&apos;;
import { injectionTargetSymbol, dynamicTargetSymbol } from &apos;./inject&apos;;
import { Symbol } from &apos;../shims/symbol&apos;;
import { _ } from &apos;../shims/lodash&apos;;
/**
 * The key to hold dependency name.
 */
export const INJECTION_NAME_SYMBOL = Symbol(&apos;__injectionname__&apos;);
/**
 * The key to hold singleton instance.
 */
const SINGLETON_KEY = Symbol(&apos;__instance__&apos;);
/**
 * The key to distinct proxied class.
 */
const PROXIED_MARK = Symbol(&apos;__proxied__&apos;);
/**
 * Dependency definition.
 */
class Injections {
    /**
     * @param ctor Constructor function.
     */
    constructor(ctor, inst) {
        /**
         * The name of depends class, instance, provider array.
         */
        this.injectionList = [];
        if (!inst) {
            this.initCtorInjections(ctor);
        }
        else {
            this.initInstanceInjections(inst);
        }
    }
    /**
     * Return dependencies list.
     * @returns The name of depends class, instance, provider array.
     */
    get injections() { return this.injectionList; }
    /**
     * Construct dependent name array.
     * @param ctor Constructor function.
     */
    initCtorInjections(ctor) {
        this.extractInjectionTarget(ctor, injectionTargetSymbol);
        this.extractInjectionTarget(ctor, dynamicTargetSymbol);
    }
    /**
     * Construct dependent name array.
     * @param ctor Constructor function.
     */
    initInstanceInjections(inst) {
        this.extractInjectionTarget(inst, injectionTargetSymbol);
        this.extractInjectionTarget(inst, dynamicTargetSymbol);
    }
    /**
     * Extract configs by symbol.
     * @param target Target object.
     * @param symbol Symbol object.
     */
    extractInjectionTarget(target, symbol) {
        var resources = target[symbol];
        if (!_.isArray(resources)) {
            if (!resources) {
                resources = [];
            }
            else {
                resources = [resources];
            }
        }
        this.injectionList = this.injectionList.concat(resources);
    }
}
/**
 * The main class.
 */
export class Injector {
    /**
     * @param modules The module array that is defined dependencies.
     */
    constructor(modules) {
        /**
         * Definition of bindings.
         */
        this.bindings = {};
        /**
         * Definition of interceptor bindings.
         */
        this.intercepts = [];
        /**
         * Definition of template bindings.
         */
        this.templates = {};
        /**
         * Definition of template.
         */
        this.templateDefinitions = {};
        this.initialize(modules);
    }
    /**
     * Iniaitlize modules and injector.
     * @param modules The `Module` that are defined dependency relations.
     */
    initialize(modules) {
        var obj = {};
        _.forEach(modules, (mod) =&gt; {
            mod.configure();
            _.extend(obj, mod.getBindings());
            _.extend(this.templates, mod.getTemplates());
            this.intercepts = this.intercepts.concat(mod.getIntercepts() || []);
        });
        obj[&apos;injector&apos;] = this.fromParams(this);
        this.bindings = obj;
        this.instantiateEagerSingletons();
    }
    /**
     * Instantiate eagerSingleton class.
     */
    instantiateEagerSingletons() {
        _.forIn(this.bindings, (v, k) =&gt; {
            if (v.eagerSingleton) {
                this.getInstanceFromSelf(k);
            }
        });
    }
    /**
     * Construct dependency resolved instance.
     *
     * @param ctor Constructor function
     * @param params Additional dependencies.
     * @returns Dependency resolved instance.
     * @example
     *
     * class Foo {...}
     *
     * class Bar {
     *   @inject()
     *   private foo
     *
     *   constructor() {}
     * }
     *
     * class TestModule extends AbstractModule {
     *   public configure() {
     *     this.bind(&apos;foo&apos;).to(Foo);
     *   }
     * }
     *
     * var injector = new Injector([new TestModule()]);
     *
     * //This call inject foo property of class Bar to module defined value.
     * injector.inject&lt;Bar&gt;(Bar);
     */
    inject(ctor, params) {
        var injections = new Injections(ctor);
        return this.doCreate(ctor, injections, params);
    }
    /**
     * Inject dependency to instance.
     *
     * @param inst Instance.
     * @param params Additional dependencies.
     * @returns Dependency injected instance.
     * @example
     *
     * class Foo {...}
     *
     * class Bar {
     *   @inject()
     *   private foo
     *
     *   constructor() {}
     * }
     *
     * class TestModule extends AbstractModule {
     *   public configure() {
     *     this.bind(&apos;foo&apos;).to(Foo);
     *   }
     * }
     *
     * var injector = new Injector([new TestModule()]);
     *
     * //This call inject foo property of class Bar to module defined value.
     * injector.injectToInstance&lt;Bar&gt;(new Bar());
     */
    injectToInstance(inst, params) {
        if (inst[injectionTargetSymbol]) {
            let keyArgs = this.createArguments(new Injections(null, inst), params, true);
            return _.extend(inst, keyArgs);
        }
        return inst;
    }
    /**
     * Resolve dependencies at once.
     * If passed same constructor function twice,
     * return first time instantiated instance.
     * @param ctor Constructor function.
     * @param params Additional dependencies.
     */
    injectOnce(ctor, params) {
        if (!ctor[SINGLETON_KEY]) {
            ctor[SINGLETON_KEY] = this.inject(ctor, params);
        }
        return ctor[SINGLETON_KEY];
    }
    /**
     * Create child injector of passed injector.
     * @param modules The new module to add.
     */
    createChildInjector(modules) {
        const injector = new Injector(modules);
        injector.parent = this;
        return injector;
    }
    /**
     * Get instance from self and parents.
     * @param key The key of dependency.
     * @return The instance that created from found dependency.
     */
    get(key) {
        let instance = null;
        let injector = this;
        while (injector &amp;&amp; !(instance = injector.getInstanceFromSelf(key))) {
            injector = injector.parent;
        }
        return instance;
    }
    /**
     * Get instance from self, not includes parents.
     * @param key The key of dependency.
     * @returns The instance that created from found dependency.
     */
    getInstanceFromSelf(key) {
        let ret;
        if (typeof key === &apos;string&apos;) {
            ret = _.filter(_.assign(this.bindings, this.templates), (binding, name) =&gt; name === key)[0];
            let instance = ret ? this.getInstance(key, null, ret, ret.template) : null;
            return instance;
        }
        else {
            ret = [];
            _.forIn(_.assign(this.bindings, this.templates), (binding, name) =&gt; {
                if (key.test(name)) {
                    let instance = this.getInstance(name, null, binding, binding.template);
                    ret.push(instance);
                }
            });
        }
        return ret;
    }
    /**
     * Return all registered dependent names of self, not includes parents.
     * @returns List of dependent names.
     */
    selfKeys() {
        return _.map(this.bindings, (binding, name) =&gt; name);
    }
    /**
     * @return all registerd dependent names.
     * @return List of dependent names.
     */
    keys() {
        let ret = [];
        this.findOnParent(bindings =&gt; {
            ret = ret.concat(_.map(bindings, (binding, name) =&gt; name));
            return true;
        });
        return ret;
    }
    /**
     * Create instance and resolve bindings.
     * @param ctor Constructor function.
     * @param injections Dependencies.
     * @returns The instance that dependencies injected.
     */
    doCreate(ctor, injections, params) {
        let args = this.createArguments(injections, params, false);
        let ret = this.invokeNewCall(ctor, args);
        if (ret[injectionTargetSymbol] || ret[dynamicTargetSymbol]) {
            let keyArgs = this.createArguments(new Injections(null, ret), params, true);
            _.assign(ret, keyArgs);
        }
        if (this.intercepts.length &gt; 0) {
            this.applyInterceptor(ret);
        }
        if (ret &amp;&amp; ret[&apos;postInit&apos;]) {
            ret[&apos;postInit&apos;]();
        }
        return ret;
    }
    /**
     * Instantiate class.
     * To fast instantiation, not use Function.prototype.apply but use switch case.
     * @param ctor Constructor function.
     * @param args Arguments.
     * @return The instance that dependencies injected.
     */
    invokeNewCall(ctor, args) {
        var instance;
        switch (args.length) {
            case 0:
                instance = new ctor();
                break;
            case 1:
                instance = new ctor(args[0]);
                break;
            case 2:
                instance = new ctor(args[0], args[1]);
                break;
            case 3:
                instance = new ctor(args[0], args[1], args[2]);
                break;
            case 4:
                instance = new ctor(args[0], args[1], args[2], args[3]);
                break;
            case 5:
                instance = new ctor(args[0], args[1], args[2], args[3], args[4]);
                break;
            case 6:
                instance = new ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                break;
            case 7:
                instance = new ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                break;
            case 8:
                instance = new ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
                break;
            case 9:
                instance = new ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
                break;
            case 10:
                instance = new ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
                break;
            default:
                var dummy = () =&gt; { };
                dummy.prototype = ctor.prototype;
                instance = new dummy;
                ctor.apply(instance, args);
        }
        return instance;
    }
    /**
     * Create arguments from bindings.
     * @param injections Dependencies.
     * @returns Array of dependencies.
     */
    createArguments(injections, params, useKeys) {
        const args = [];
        const keyArgs = {};
        const resources = injections.injections;
        const keys = params ? _.keys(params) : [];
        let bindingInfo;
        let bindingName;
        let dynamicName;
        let passProvider = false;
        let i = 0;
        let len;
        if (!resources) {
            return args;
        }
        for (i = 0, len = resources.length; i &lt; len; i++) {
            var isDynamic = resources[i].length === 3;
            bindingName = resources[i][0];
            dynamicName = isDynamic ? resources[i][1] : null;
            if (_.isRegExp(bindingName)) {
                var inner = [];
                this.findOnParent((bindings, templates) =&gt; {
                    _.forEach(_.assign(bindings, templates), (binding, name) =&gt; {
                        bindingName.test(name) &amp;&amp; inner.push(this.getInstance(name, null, binding, false));
                        _.forEach(keys, key =&gt; {
                            if (bindingName.test(key)) {
                                inner.push(this.getInstance(key, null, this.fromParams(params[key]), false));
                            }
                        });
                    });
                    return true;
                });
                if (!useKeys) {
                    args.push(inner);
                }
                else {
                    keyArgs[resources[i][1]] = this.getInstance(bindingName, null, item, false);
                }
            }
            else {
                var item;
                this.findOnParent((bindings, templates) =&gt; {
                    item = bindings[bindingName] || templates[bindingName] || (params ? this.fromParams(params[bindingName]) : null);
                    if (item) {
                        return false;
                    }
                    return true;
                });
                if (!item) {
                    args.push(null);
                    continue;
                }
                if (!useKeys) {
                    args.push(this.getInstance(bindingName, dynamicName, item, isDynamic));
                }
                else {
                    keyArgs[isDynamic ? resources[i][2] : resources[i][1]] = this.getInstance(bindingName, dynamicName, item, isDynamic);
                }
            }
        }
        return useKeys ? keyArgs : args;
    }
    /**
     * Search include parents `Injector`.
     * Until passed callback return true, traverse parents.
     * @param cb Callback function.
     */
    findOnParent(cb) {
        var injector = this;
        while (injector) {
            var ret = cb(injector.bindings, injector.templates);
            if (!ret) {
                return;
            }
            injector = injector.parent;
        }
    }
    /**
     * Create binding from additional parameter.
     * @param val defined value in Binding.
     * @returns Binding definition.
     */
    fromParams(val) {
        return {
            val: val,
            singleton: false,
            eagerSingleton: false,
            instance: true,
            provider: false,
            template: false
        };
    }
    /**
     * Create dependent instance.
     * @param bindingName Instance name.
     * @param item The defitnition of dependencies.
     * @returns The instance that is constructed.
     */
    getInstance(bindingName, dynamicName, item, isTemplate) {
        if (isTemplate &amp;&amp; dynamicName &amp;&amp; this.templateDefinitions[dynamicName]) {
            return this.templateDefinitions[dynamicName];
        }
        var ret;
        if (item &amp;&amp; !item.instance &amp;&amp; !item.provider) {
            if (item.singleton) {
                if (!item[&apos;_instance&apos;]) {
                    item[&apos;_instance&apos;] = this.inject(item.val);
                    item[&apos;_instance&apos;][INJECTION_NAME_SYMBOL] = bindingName;
                }
                ret = item[&apos;_instance&apos;];
            }
            else {
                var instance = this.inject(item.val);
                instance[INJECTION_NAME_SYMBOL] = bindingName;
                ret = instance;
            }
        }
        else if (item.instance) {
            ret = item.val;
        }
        else if (item.provider) {
            var provider = this.inject(item.val);
            var provided = provider.provide();
            if (!_.isNil(provided)) {
                provided[INJECTION_NAME_SYMBOL] = bindingName;
            }
            ret = provided;
        }
        else {
            ret = null;
        }
        if (this.intercepts.length &gt; 0) {
            this.applyInterceptor(ret);
        }
        if (isTemplate &amp;&amp; dynamicName) {
            this.templateDefinitions[dynamicName] = ret;
        }
        return ret;
    }
    /**
     * Hook interceptor.
     * @param Target instance.
     */
    applyInterceptor(inst) {
        if (inst[PROXIED_MARK]) {
            return;
        }
        _.every(this.intercepts, (i) =&gt; {
            if (inst[i.targetSymbol]) {
                if (_.isRegExp(inst[i.targetSymbol][0])) {
                    const regexp = inst[i.targetSymbol][0];
                    _.forIn(inst, (v, k) =&gt; {
                        if (regexp.test(k)) {
                            inst[k] = this.getMethodProxy(inst, v, this.getInterceptorInstance(i), k);
                        }
                    });
                    return false;
                }
                else {
                    _.forIn(inst[i.targetSymbol], (s) =&gt; {
                        if (inst[s]) {
                            if (typeof inst[s] !== &apos;function&apos;) {
                                throw new Error(`Interceptor only applyable to function.\nBut property ${s} is ${Object.prototype.toString.call(inst[s])}`);
                            }
                            inst[s] = this.getMethodProxy(inst, inst[s], this.getInterceptorInstance(i), s);
                        }
                    });
                }
                inst[PROXIED_MARK] = true;
            }
            return true;
        });
    }
    /**
     * Get interceptor instance.
     * @param i Interceptor class.
     * @returns INterceptor instance.
     */
    getInterceptorInstance(i) {
        if (!i.interceptor[SINGLETON_KEY]) {
            return this.inject(i.interceptor);
        }
        return i.interceptor[SINGLETON_KEY];
    }
    /**
     * Return wrapped method by interceptor.
     * @param context Execution context.
     * @param base Real method.
     * @param interceptor Instance of interceptor.
     * @param propertyKey Property name.
     * @returns Wrapped function.
     */
    getMethodProxy(context, base, interceptor, propertyKey) {
        return (...args) =&gt; {
            return interceptor.invoke(new MethodInvocation(base, context, args, context[INJECTION_NAME_SYMBOL], propertyKey));
        };
    }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.7)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
